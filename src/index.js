import eventEmitter from 'event-emitter';
import allOff from 'event-emitter/all-off';
import createAudioContext from 'ios-safe-audio-context';
// import MultiMap from './util/MultiMap';

// todo: MIN_LOOK_AHEAD might be longer for offline context
const MIN_LOOK_AHEAD = 0.05; // seconds
// const MIN_LATENCY = 0.05;
const MAX_SCHEDULED_SOUNDS = 40;
// const MIN_INTERVAL = 0.000001;

let mainContext = null;
const mainContextUsers = new Set();

function getMainContext(instance) {
	if (!mainContext) {
		mainContext = createAudioContext();
	}
	mainContextUsers.add(instance);
	return mainContext;
}

function releaseMainContext(instance) {
	mainContextUsers.delete(instance);
	if (!mainContextUsers.size && mainContext) {
		if (mainContext.close && mainContext.state !== 'closed') {
			mainContext.close();
		}
		mainContext = null;
	}
}

// sort by start time
function sortUnscheduled(a, b) {
	const startDiff = a.startTime - b.startTime;
	if (startDiff) {
		return startDiff;
	}

	const stopDiff = a.stopTime - b.stopTime;
	if (stopDiff) {
		return stopDiff;
	}

	const releaseDiff = a.releaseTime - b.releaseTime;
	if (releaseDiff) {
		return releaseDiff;
	}

	return a.id - b.id;
}

function sortPlayed(a, b) {
	const stopDiff = a.stopTime - b.stopTime;
	if (stopDiff) {
		return stopDiff;
	}

	const releaseDiff = a.releaseTime - b.releaseTime;
	if (releaseDiff) {
		return releaseDiff;
	}

	const startDiff = a.startTime - b.startTime;
	if (startDiff) {
		return startDiff;
	}

	return a.id - b.id;
}

let nextSoundEventId = 1;

function SoundQ(options = {}) {
	const context = options.context || getMainContext(this);

	// todo: get pool limits from options

	// queues, maps and sets for various pools and events
	const allSources = new Map();
	const allShots = new Set();
	const liveShots = new Map(); // by id
	const backloggedShots = [];
	const soundEvents = new Map();
	const unscheduledQueue = [];
	const playedSounds = [];

	let scheduling = false;
	let nextScheduleTime = Infinity;
	let earliestStopTime = Infinity;
	let nextShotId = 1;

	function startSoundEvent(sound) {
		if (sound.shot.startEvent) {
			sound = Object.assign(sound, sound.shot.startEvent(sound));
			sound.scheduled = true;
		}

		// todo: connect output to destination
		if (sound.output && sound.output.connect) {
			sound.output.connect(context.destination);
		}

		nextScheduleTime = Math.min(nextScheduleTime, sound.stopTime);

		const needsSorting = playedSounds.length && sound.startTime <= playedSounds[0].startTime;
		playedSounds.push(sound);
		if (needsSorting) {
			playedSounds.sort(sortPlayed);
		}
	}

	/*
	Schedule individual sound events generated by sources
	*/
	function scheduleSounds() {
		if (scheduling) {
			return;
		}

		scheduling = true;
		nextScheduleTime = Math.max(nextScheduleTime, context.currentTime + MIN_LOOK_AHEAD);

		// todo: loop this over and over until we have enough to take use through earliest endTime?
		liveShots.forEach(source => {
			if (source.drain) {
				source.drain(nextScheduleTime);
			}
		});

		/*
		todo: loop through any started sound events
		- fade out anything that's been playing a long time if we're over the limit
		- cancel anything that's too far out
		- this queue is sorted by end time
		*/
		// for (let i = 0, n = playedSounds.length; i < n; i++) {
		// 	const sound = playedSounds[i];
		// }

		/*
		todo: loop through submitted sound events
		- find new nextScheduleTime
		- cancel anything that's too far out
		- this queue is sorted by start time
		  - so we can end early
		  - efficiently store earliest stopTime
		  - probably faster to use binary insert
		*/
		nextScheduleTime = Infinity;
		for (let i = 0, n = unscheduledQueue.length; i < n && playedSounds.length < MAX_SCHEDULED_SOUNDS; i++) {
			const sound = unscheduledQueue[i];

			/*
			todo:
			note that the time between NOW and startTime should be less than min latency...
			Use the time between the FIRST stopTime of scheduled sound and startTime.
			*/
			if (playedSounds.length < 3 || sound.startTime - context.currentTime < MIN_LOOK_AHEAD) {
				unscheduledQueue.splice(i, 1);
				i--;
				n--;

				if (sound.stopTime > context.currentTime) {
					startSoundEvent(sound);
				} else {
					// we missed one!
					// todo: make this do something!
					revoke(sound.id);
				}
			}
		}

		scheduling = false;
	}

	/*
	Schedule shots initiated by calls to .start on a shot
	*/
	function scheduleShots() {
		scheduleSounds();
	}

	function revoke(eventId) {
		const index = playedSounds.findIndex(s => s.id === eventId);
		if (index >= 0) {
			const sound = playedSounds[index];
			sound.stopped = true;

			playedSounds.splice(index, 1);

			if (sound.shot.finishEvent) {
				sound.shot.finishEvent(sound);
			}

			soundEvents.delete(eventId);
			// todo: fire stop event

			if (/*context.currentTime < sound.stopTime &&*/ sound.startTime < context.currentTime) {
				// only schedule further if this sound has actually played
				scheduleShots();
			}
		}
	}

	function end(id, stopTime) {
		const sound = soundEvents.get(id);
		if (id && sound.stopTime !== stopTime) {
			sound.stopTime = stopTime;
			if (sound.scheduled && sound.shot.stopEvent) {
				sound.shot.stopEvent(sound);

				// re-sort played sounds, update earliest stopTime if needed
				playedSounds.sort(sortPlayed);

				earliestStopTime = Infinity;
				for (let i = 0; i < playedSounds.length; i++) {
					const st = playedSounds[i].stopTime;
					if (st > context.currentTime) {
						earliestStopTime = st;
						break;
					}
				}

			}
			scheduleShots();
		}
	}

	this.context = context;

	function makeSourceShot(sourceDef) {
		const {
			definition,
			options
		} = sourceDef;

		let shot = null;

		const sourceController = {
			context,

			// todo: move functions up to top level if possible
			submit(details) {
				const id = details.id || nextSoundEventId++;
				const soundEvent = soundEvents.get(id) || {
					id,
					shot,
					output: null,
					scheduled: false,
					releaseTime: Infinity,
					stopTime: Infinity
				};
				Object.assign(soundEvent, details);
				soundEvent.releaseTime = Math.min(soundEvent.releaseTime, soundEvent.stopTime);

				if (!soundEvents.has(id)) {
					const needsSorting = unscheduledQueue.length && soundEvent.startTime <= unscheduledQueue[0].startTime;
					unscheduledQueue.push(soundEvent);
					if (needsSorting) {
						// only sort when we need to
						unscheduledQueue.sort(sortUnscheduled);
					}
					soundEvents.set(id, soundEvent);
				}

				// todo: allow updating of already played event
				// scheduleSounds(); ?

				return id;
			},

			// means we're really, really done with this
			revoke,

			// clean up
			end
		};

		shot = definition(sourceController, options);
		shot.stopped = false;

		return shot;
	}

	function startSourceShot(shot, time = context.currentTime, options) {
		// todo: what if we're already started?
		if (shot.start) {
			shot.start(time, options);
		}
		// todo: set release, stopTime to Infinity
		scheduleShots();
	}

	function releaseSourceShot(shot, time = context.currentTime) {
		// todo: what if we're already released?
		if (shot.release) {
			shot.release(time);
		} else if (shot.stop) {
			shot.stop(time);
		}
		scheduleShots();
	}

	function stopSourceShot(shot, time = context.currentTime) {
		// todo: what if we're already stopped?
		// todo: release if release time is before this
		if (shot.stop) {
			shot.stop(time);
		}
		scheduleShots();
	}

	function destroySourceShot() {
	}

	/*
	todo: can we eliminate this?
	- just pass def and options to shot every time (too many params?)
	- store pool in MultiMap
	*/
	this.source = (definition, options) => {
		const s = Symbol();
		allSources.set(s, {
			definition,
			options,
			pool: []
		});
		return s;
	};

	/*
	todo:
	- add events to shot
	- find out and report if shot is reusable
	*/
	this.shot = (source, patch) => {
		// todo: if source is a buffer, create a new source for it
		// todo: if source is an AudioScheduledSourceNode, create new source for it?
		// todo: shuffle around order so code makes sense
		// todo: get destination somewhere. shot options? play options?

		// if (options === undefined && typeof patch !== 'function') {
		// 	options = patch;
		// 	patch = null;
		// }

		const sourceDef = allSources.get(source);
		if (!sourceDef) {
			throw new Error('Unknown source');
		}

		const {
			// definition,
			// options: sourceOpts,
			pool: sourcePool
		} = sourceDef;

		// todo: emit events
		const shot = {
			context,
			start(startTime, options) {
				/*
				todo: queue up these start events
				- if start is after lookahead, stick it in a queue
				- update when we have a new stop time
				*/
				const id = nextShotId++;
				const shotPrivate = sourcePool.length ?
					sourcePool.pop() :
					makeSourceShot(sourceDef);

				// todo: set up patch from pool w/ options

				liveShots.set(id, shotPrivate);
				startSourceShot(shotPrivate, startTime, options);
				return id;
			},
			release(releaseTime, id) {
				// todo: handle missing id for this shot def
				const shotPrivate = liveShots.get(id);
				if (shotPrivate) {
					releaseSourceShot(shotPrivate, releaseTime);
				}
			},
			stop(stopTime, id) {
				// todo: handle missing id for this shot def
				const shotPrivate = liveShots.get(id);
				liveShots.delete(id);
				if (shotPrivate) {
					stopSourceShot(shotPrivate, stopTime);
				}
			},
			destroy() {
				console.log('todo: destroy');
				// destroySourceShot()
			}
		};

		allShots.add(shot);

		return shot;
	};

	this.destroy = () => {
		allShots.forEach(s => s.destroy());
		releaseMainContext(this);

		this.emit('destroy');
		allOff(this);
	};
}

eventEmitter(SoundQ.prototype);

export default SoundQ;
