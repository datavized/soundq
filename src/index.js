import eventEmitter from 'event-emitter';
import allOff from 'event-emitter/all-off';
import createAudioContext from 'ios-safe-audio-context';
// import MultiMap from './util/MultiMap';

/*
definitions:
- "active" shots have been started but not yet stopped
- "live" shots have been started and possibly stopped or
  not, but still have some live/pending sound events in the queue
*/

// todo: MIN_LOOK_AHEAD might be longer for offline context
const MIN_LOOK_AHEAD = 0.05; // seconds
// const MIN_LATENCY = 0.05;
const MAX_SCHEDULED_SOUNDS = 40;
// const MIN_INTERVAL = 0.000001;

let mainContext = null;
const mainContextUsers = new Set();

function getMainContext(instance) {
	if (!mainContext) {
		mainContext = createAudioContext();
	}
	mainContextUsers.add(instance);
	return mainContext;
}

function releaseMainContext(instance) {
	mainContextUsers.delete(instance);
	if (!mainContextUsers.size && mainContext) {
		if (mainContext.close && mainContext.state !== 'closed') {
			mainContext.close();
		}
		mainContext = null;
	}
}

// sort by start time
function sortUnscheduled(a, b) {
	const startDiff = a.startTime - b.startTime;
	if (startDiff) {
		return startDiff;
	}

	const stopDiff = a.stopTime - b.stopTime;
	if (stopDiff) {
		return stopDiff;
	}

	const releaseDiff = a.releaseTime - b.releaseTime;
	if (releaseDiff) {
		return releaseDiff;
	}

	return a.id - b.id;
}

function sortPlayed(a, b) {
	const stopDiff = a.stopTime - b.stopTime;
	if (stopDiff) {
		return stopDiff;
	}

	const releaseDiff = a.releaseTime - b.releaseTime;
	if (releaseDiff) {
		return releaseDiff;
	}

	const startDiff = a.startTime - b.startTime;
	if (startDiff) {
		return startDiff;
	}

	return a.id - b.id;
}

let nextSoundEventId = 1;

function SoundQ(options = {}) {
	const context = options.context || getMainContext(this);

	// todo: get pool limits from options
	// todo: periodically empty out old instances from source pools

	// queues, maps and sets for various pools and events
	const allSources = new Map();
	const allShots = new Set();
	const activeShots = new Map(); // by id
	const liveShots = new Set();
	// const backloggedShots = [];
	const soundEvents = new Map();
	const unscheduledQueue = [];
	const playedSounds = [];

	let scheduling = false;
	let earliestStopTime = Infinity;
	let nextShotId = 1;

	function startSoundEvent(sound) {
		if (sound.shot.startEvent) {
			sound = Object.assign(sound, sound.shot.startEvent(sound));
			sound.scheduled = true;
		}

		// todo: connect output to destination
		if (sound.output && sound.output.connect) {
			sound.output.connect(context.destination);
		}

		const needsSorting = playedSounds.length && sound.startTime <= playedSounds[0].startTime;
		playedSounds.push(sound);
		if (needsSorting) {
			playedSounds.sort(sortPlayed);
		}
	}

	/*
	Schedule individual sound events generated by sources
	*/
	function scheduleSounds() {
		if (scheduling) {
			return;
		}

		scheduling = true;

		const urgentTime = context.currentTime + MIN_LOOK_AHEAD;
		liveShots.forEach(source => {
			if (source.request) {
				let event = null;
				do {
					event = source.request(urgentTime);
					if (event && typeof event === 'object') {
						source.controller.submit(event);
					}
				} while (event);
			}
		});


		liveShots.forEach(source => {
			if (source.request) {
				let event = null;
				do {
					event = source.request(earliestStopTime + MIN_LOOK_AHEAD);
					if (event && typeof event === 'object') {
						source.controller.submit(event);
						earliestStopTime = Math.min(earliestStopTime, event.stopTime);
					}
				} while (event);
			}
		});
		/*
		todo: loop through any started sound events
		- fade out anything that's been playing a long time if we're over the limit
		- cancel anything that's too far out
		- this queue is sorted by stop time
		*/
		// for (let i = 0, n = playedSounds.length; i < n; i++) {
		// 	const sound = playedSounds[i];
		// }

		/*
		todo: loop through submitted sound events
		- cancel anything that's too far out
		- this queue is sorted by start time
		  - so we can end early
		  - efficiently store earliest stopTime
		  - probably faster to use binary insert
		*/
		while (unscheduledQueue.length && playedSounds.length < MAX_SCHEDULED_SOUNDS) {
			const sound = unscheduledQueue.shift();

			/*
			todo:
			note that the time between NOW and startTime should be less than min latency...
			Use the time between the FIRST stopTime of scheduled sound and startTime.
			*/
			if (sound.stopTime > context.currentTime) {
				startSoundEvent(sound);
			} else {
				// we missed one!
				// todo: make this do something! we're probably leaking memory here
				revoke(sound.id);
			}
		}

		scheduling = false;
	}

	/*
	Schedule shots initiated by calls to .start on a shot
	*/
	function scheduleShots() {
		scheduleSounds();
	}

	function calculateEarliestStopTime() {
		earliestStopTime = Infinity;
		for (let i = 0; i < playedSounds.length; i++) {
			const st = playedSounds[i].stopTime;
			if (st > context.currentTime) {
				earliestStopTime = st;
				break;
			}
		}
	}

	function revoke(eventId) {
		const index = playedSounds.findIndex(s => s.id === eventId);
		if (index >= 0) {

			const sound = playedSounds[index];
			const shot = sound.shot;
			sound.stopped = true;

			playedSounds.splice(index, 1);

			if (shot.finishEvent) {
				shot.finishEvent(sound);
			}

			calculateEarliestStopTime();

			soundEvents.delete(eventId);
			shot.events.delete(sound);
			// todo: fire stop event

			if (!shot.events.size && !shot.active) {
				// we may want to give the source a `reset` method here
				// to make sure it's clean before going back in the pool
				liveShots.delete(shot);
				shot.pool.push(shot);
			}

			if (sound.startTime < context.currentTime) {
				// only schedule further if this sound has actually played
				scheduleShots();
			}
		}
	}

	function stop(id, stopTime) {
		const sound = soundEvents.get(id);
		if (id && sound.stopTime !== stopTime) {
			sound.stopTime = stopTime;
			if (sound.scheduled) {
				if (sound.shot.stopEvent) {
					sound.shot.stopEvent(sound);
				}

				// re-sort played sounds, update earliest stopTime if needed
				playedSounds.sort(sortPlayed);

				calculateEarliestStopTime();

			}
			scheduleShots();
		}
	}

	this.context = context;

	function makeSourceShot(sourceDef) {
		const {
			definition,
			options,
			pool
		} = sourceDef;

		let shot = null;

		const controller = {
			context,

			// todo: move functions up to top level if possible
			submit(details) {
				const id = details.id || nextSoundEventId++;
				const soundEvent = soundEvents.get(id) || {
					id,
					shot,
					output: null,
					stopped: false,
					scheduled: false,
					releaseTime: Infinity,
					stopTime: Infinity
				};
				Object.assign(soundEvent, details);
				soundEvent.releaseTime = Math.min(soundEvent.releaseTime, soundEvent.stopTime);

				if (!soundEvents.has(id)) {
					const needsSorting = unscheduledQueue.length && soundEvent.startTime <= unscheduledQueue[0].startTime;
					unscheduledQueue.push(soundEvent);
					if (needsSorting) {
						// only sort when we need to
						unscheduledQueue.sort(sortUnscheduled);
					}
					soundEvents.set(id, soundEvent);
					shot.events.add(soundEvent);

					if (soundEvent.stopTime >= context.currentTime) {
						earliestStopTime = Math.min(earliestStopTime, soundEvent.stopTime);
					}
				} else {
					console.warn('double submit on event', soundEvent);
				}

				// todo: allow updating of already played event
				// scheduleSounds(); ?

				return id;
			},

			// means we're really, really done with this
			revoke,

			// clean up
			stop
		};

		shot = Object.assign(definition(controller, options), {
			controller,
			active: false,
			events: new Set(),
			pool
		});

		return shot;
	}

	function startSourceShot(shot, time = context.currentTime, options) {
		// todo: what if we're already active?
		if (shot.start) {
			shot.start(time, options);
		}
		// todo: set release, stopTime to Infinity

		scheduleShots();
	}

	function releaseSourceShot(shot, time = context.currentTime) {
		// todo: what if we're already released?
		if (shot.release) {
			shot.release(time);
		} else if (shot.stop) {
			shot.stop(time);
		}
		scheduleShots();
	}

	function stopSourceShot(shot, time = context.currentTime) {
		// todo: what if we're already stopped?
		// todo: release if release time is before this
		if (shot.stop) {
			shot.stop(time);
		}
		scheduleShots();
	}

	// function destroySourceShot(shot) {
	// }

	/*
	todo: can we eliminate this?
	- just pass def and options to shot every time (too many params?)
	- store pool in MultiMap
	*/
	this.source = (definition, options) => {
		const s = Symbol();
		allSources.set(s, {
			definition,
			options,
			pool: []
		});
		return s;
	};

	/*
	todo:
	- add events to shot
	- find out and report if shot is reusable
	*/
	this.shot = (source/*, patch*/) => {
		// todo: if source is a buffer, create a new source for it
		// todo: if source is an AudioScheduledSourceNode, create new source for it?
		// todo: shuffle around order so code makes sense
		// todo: get destination somewhere. shot options? play options?

		// if (options === undefined && typeof patch !== 'function') {
		// 	options = patch;
		// 	patch = null;
		// }

		const sourceDef = allSources.get(source);
		if (!sourceDef) {
			throw new Error('Unknown source');
		}

		const {
			// definition,
			// options: sourceOpts,
			pool: sourcePool
		} = sourceDef;

		// todo: emit events
		const shot = {
			context,
			start(startTime, options) {
				/*
				todo: queue up these start events
				- if start is after lookahead, stick it in a queue
				- update when we have a new stop time
				*/
				const id = nextShotId++;
				const shotPrivate = sourcePool.length ?
					sourcePool.pop() :
					makeSourceShot(sourceDef);

				// todo: set up patch from pool w/ options

				shotPrivate.active = true;
				liveShots.add(shotPrivate);
				activeShots.set(id, shotPrivate);
				startSourceShot(shotPrivate, startTime, options);
				return id;
			},
			release(releaseTime, id) {
				// todo: handle missing id for this shot def
				const shotPrivate = activeShots.get(id);
				if (shotPrivate) {
					releaseSourceShot(shotPrivate, releaseTime);
				}
			},
			stop(stopTime, id) {
				// todo: handle missing id for this shot def
				const shotPrivate = activeShots.get(id);
				shotPrivate.active = false;
				activeShots.delete(id);
				if (shotPrivate) {
					stopSourceShot(shotPrivate, stopTime);
				}
			},
			destroy() {
				console.log('todo: destroy');
				// destroySourceShot()
			}
		};

		allShots.add(shot);

		return shot;
	};

	this.destroy = () => {
		allShots.forEach(s => s.destroy());
		releaseMainContext(this);

		this.emit('destroy');
		allOff(this);
	};
}

eventEmitter(SoundQ.prototype);

export default SoundQ;
